// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_
#define FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_

#include "flatbuffers/flatbuffers.h"

namespace Editor {

struct EditorRoot;

struct NodeTree;

struct AnchorPoint;

struct Color;

struct Vector;

enum NodeType {
  NodeType_BUTTON = 0,
  NodeType_SPRITE = 1,
  NodeType_LAYOUT = 2,
  NodeType_MIN = NodeType_BUTTON,
  NodeType_MAX = NodeType_LAYOUT
};

inline NodeType (&EnumValuesNodeType())[3] {
  static NodeType values[] = {
    NodeType_BUTTON,
    NodeType_SPRITE,
    NodeType_LAYOUT
  };
  return values;
}

inline const char **EnumNamesNodeType() {
  static const char *names[] = {
    "BUTTON",
    "SPRITE",
    "LAYOUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeType()[index];
}

MANUALLY_ALIGNED_STRUCT(4) AnchorPoint FLATBUFFERS_FINAL_CLASS {
 private:
  float scaleX_;
  float scaleY_;

 public:
  AnchorPoint() {
    memset(this, 0, sizeof(AnchorPoint));
  }
  AnchorPoint(float _scaleX, float _scaleY)
      : scaleX_(flatbuffers::EndianScalar(_scaleX)),
        scaleY_(flatbuffers::EndianScalar(_scaleY)) {
  }
  float scaleX() const {
    return flatbuffers::EndianScalar(scaleX_);
  }
  float scaleY() const {
    return flatbuffers::EndianScalar(scaleY_);
  }
};
STRUCT_END(AnchorPoint, 8);

MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t a_;
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  Color() {
    memset(this, 0, sizeof(Color));
  }
  Color(uint8_t _a, uint8_t _r, uint8_t _g, uint8_t _b)
      : a_(flatbuffers::EndianScalar(_a)),
        r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)) {
  }
  uint8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
};
STRUCT_END(Color, 4);

MANUALLY_ALIGNED_STRUCT(4) Vector FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector() {
    memset(this, 0, sizeof(Vector));
  }
  Vector(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vector, 8);

struct EditorRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TEXTURES = 4,
    VT_NODES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.Verify(textures()) &&
           verifier.VerifyVectorOfStrings(textures()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct EditorRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures) {
    fbb_.AddOffset(EditorRoot::VT_TEXTURES, textures);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> nodes) {
    fbb_.AddOffset(EditorRoot::VT_NODES, nodes);
  }
  explicit EditorRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EditorRootBuilder &operator=(const EditorRootBuilder &);
  flatbuffers::Offset<EditorRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EditorRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<EditorRoot> CreateEditorRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> nodes = 0) {
  EditorRootBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_textures(textures);
  return builder_.Finish();
}

inline flatbuffers::Offset<EditorRoot> CreateEditorRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *textures = nullptr,
    const std::vector<flatbuffers::Offset<NodeTree>> *nodes = nullptr) {
  return Editor::CreateEditorRoot(
      _fbb,
      textures ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*textures) : 0,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*nodes) : 0);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4,
    VT_CHILDREN = 6,
    VT_TYPE = 8
  };
  const Vector *position() const {
    return GetStruct<const Vector *>(VT_POSITION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN);
  }
  NodeType type() const {
    return static_cast<NodeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct NodeTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const Vector *position) {
    fbb_.AddStruct(NodeTree::VT_POSITION, position);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) {
    fbb_.AddOffset(NodeTree::VT_CHILDREN, children);
  }
  void add_type(NodeType type) {
    fbb_.AddElement<int8_t>(NodeTree::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeTreeBuilder &operator=(const NodeTreeBuilder &);
  flatbuffers::Offset<NodeTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeTree>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector *position = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
    NodeType type = NodeType_BUTTON) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_position(position);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector *position = 0,
    const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
    NodeType type = NodeType_BUTTON) {
  return Editor::CreateNodeTree(
      _fbb,
      position,
      children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0,
      type);
}

inline const Editor::EditorRoot *GetEditorRoot(const void *buf) {
  return flatbuffers::GetRoot<Editor::EditorRoot>(buf);
}

inline bool VerifyEditorRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Editor::EditorRoot>(nullptr);
}

inline void FinishEditorRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Editor::EditorRoot> root) {
  fbb.Finish(root);
}

}  // namespace Editor

#endif  // FLATBUFFERS_GENERATED_EDITORROOT_EDITOR_H_
